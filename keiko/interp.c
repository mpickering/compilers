/* Instruction interpreter -- generated by iset.tcl */

/*
 * iskel.c
 * 
 * This file is part of the Oxford Oberon-2 compiler
 * Copyright (c) 2006 J. M. Spivey
 * All rights reserved
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $Id: iskel.c 1700 2012-02-09 15:12:08Z mike $
 */

/* This file is the skeleton of the bytecode interpreter; the parts
   specific to each instruction are inserted from the file
   'keiko.iset' by the script 'iset.tcl'.  There are four places that
   code is inserted, each marked by two dollar signs.  In order of
   appearance, they are:

   1. A list of instructions used for disassembling the byte code
     (used if TRACE is defined).

   2. A jump table for quick dispatching (used if JTABLE is defined).

   3. Macro definitions used in the action routines.

   4. Action routines for each instruction, forming the cases in a big
      switch. */

#include <math.h>
#include "obx.h"
#include "keiko.h"

const char *iskel_rcsid = "$Id: iskel.c 1700 2012-02-09 15:12:08Z mike $";

#ifdef HAVE_INDEXED_JUMPS
#define JTABLE 1
#endif

#ifdef TRACE
#define DISASS 1
#undef JTABLE
#define do_find_proc if (dflag > 1) thisproc = find_proc(cp)
#else
#define do_find_proc
#endif

#ifdef PROFILE
#undef JTABLE
#endif

#ifdef OBXDEB
#define DISASS 1
#endif

#ifdef DISASS
struct _opcode optable[256] = {
     { "ILLEGAL", "", 0, 1 },
     { "PUSH", "N", -1, 1 },
     { "PUSH", "N", 0, 1 },
     { "PUSH", "N", 1, 1 },
     { "PUSH", "N", 2, 1 },
     { "PUSH", "N", 3, 1 },
     { "PUSH", "N", 4, 1 },
     { "PUSH", "N", 5, 1 },
     { "PUSH", "N", 6, 1 },
     { "PUSH", "1", 0, 2 },
     { "PUSH", "2", 0, 3 },
     { "LDKW", "1", 0, 2 },
     { "LDKW", "2", 0, 3 },
     { "LDKF", "1", 0, 2 },
     { "LDKF", "2", 0, 3 },
     { "LOCAL", "1", 0, 2 },
     { "LOCAL", "2", 0, 3 },
     { "INDEXC", "", 0, 1 },
     { "INDEXS", "", 0, 1 },
     { "INDEXW", "", 0, 1 },
     { "INDEXD", "", 0, 1 },
     { "LOADW", "", 0, 1 },
     { "LOADS", "", 0, 1 },
     { "LOADC", "", 0, 1 },
     { "LOADF", "", 0, 1 },
     { "STOREW", "", 0, 1 },
     { "STORES", "", 0, 1 },
     { "STOREC", "", 0, 1 },
     { "STOREF", "", 0, 1 },
     { "LDLW", "N", -24, 1 },
     { "LDLW", "N", -20, 1 },
     { "LDLW", "N", -16, 1 },
     { "LDLW", "N", -12, 1 },
     { "LDLW", "N", -8, 1 },
     { "LDLW", "N", -4, 1 },
     { "LDLW", "N", 12, 1 },
     { "LDLW", "N", 16, 1 },
     { "LDLW", "N", 20, 1 },
     { "LDLW", "N", 24, 1 },
     { "LDLW", "N", 28, 1 },
     { "LDLW", "N", 32, 1 },
     { "LDLW", "1", 0, 2 },
     { "LDLW", "2", 0, 3 },
     { "LDLS", "1", 0, 2 },
     { "LDLS", "2", 0, 3 },
     { "LDLC", "1", 0, 2 },
     { "LDLC", "2", 0, 3 },
     { "LDLF", "1", 0, 2 },
     { "LDLF", "2", 0, 3 },
     { "STLW", "N", -24, 1 },
     { "STLW", "N", -20, 1 },
     { "STLW", "N", -16, 1 },
     { "STLW", "N", -12, 1 },
     { "STLW", "N", -8, 1 },
     { "STLW", "N", -4, 1 },
     { "STLW", "N", 12, 1 },
     { "STLW", "N", 16, 1 },
     { "STLW", "N", 20, 1 },
     { "STLW", "N", 24, 1 },
     { "STLW", "N", 28, 1 },
     { "STLW", "N", 32, 1 },
     { "STLW", "1", 0, 2 },
     { "STLW", "2", 0, 3 },
     { "STLS", "1", 0, 2 },
     { "STLS", "2", 0, 3 },
     { "STLC", "1", 0, 2 },
     { "STLC", "2", 0, 3 },
     { "STLF", "1", 0, 2 },
     { "STLF", "2", 0, 3 },
     { "LDGW", "K", 0, 2 },
     { "LDGW", "L", 0, 3 },
     { "LDGS", "K", 0, 2 },
     { "LDGS", "L", 0, 3 },
     { "LDGC", "K", 0, 2 },
     { "LDGC", "L", 0, 3 },
     { "LDGF", "K", 0, 2 },
     { "LDGF", "L", 0, 3 },
     { "STGW", "K", 0, 2 },
     { "STGW", "L", 0, 3 },
     { "STGS", "K", 0, 2 },
     { "STGS", "L", 0, 3 },
     { "STGC", "K", 0, 2 },
     { "STGC", "L", 0, 3 },
     { "STGF", "K", 0, 2 },
     { "STGF", "L", 0, 3 },
     { "LDNW", "N", -16, 1 },
     { "LDNW", "N", -12, 1 },
     { "LDNW", "N", -8, 1 },
     { "LDNW", "N", -4, 1 },
     { "LDNW", "N", 0, 1 },
     { "LDNW", "N", 4, 1 },
     { "LDNW", "N", 8, 1 },
     { "LDNW", "N", 12, 1 },
     { "LDNW", "N", 16, 1 },
     { "LDNW", "N", 20, 1 },
     { "LDNW", "N", 24, 1 },
     { "LDNW", "N", 28, 1 },
     { "LDNW", "N", 32, 1 },
     { "LDNW", "N", 36, 1 },
     { "LDNW", "N", 40, 1 },
     { "LDNW", "1", 0, 2 },
     { "LDNW", "2", 0, 3 },
     { "STNW", "N", -16, 1 },
     { "STNW", "N", -12, 1 },
     { "STNW", "N", -8, 1 },
     { "STNW", "N", -4, 1 },
     { "STNW", "N", 0, 1 },
     { "STNW", "N", 4, 1 },
     { "STNW", "N", 8, 1 },
     { "STNW", "N", 12, 1 },
     { "STNW", "N", 16, 1 },
     { "STNW", "N", 20, 1 },
     { "STNW", "1", 0, 2 },
     { "STNW", "2", 0, 3 },
     { "LDIW", "", 0, 1 },
     { "LDIF", "", 0, 1 },
     { "LDIS", "", 0, 1 },
     { "LDIC", "", 0, 1 },
     { "STIW", "", 0, 1 },
     { "STIF", "", 0, 1 },
     { "STIS", "", 0, 1 },
     { "STIC", "", 0, 1 },
     { "LDEW", "1", 0, 2 },
     { "LDEW", "2", 0, 3 },
     { "STEW", "1", 0, 2 },
     { "STEW", "2", 0, 3 },
     { "LOADD", "", 0, 1 },
     { "STORED", "", 0, 1 },
     { "LDKD", "1", 0, 2 },
     { "LDKD", "2", 0, 3 },
     { "LOADQ", "", 0, 1 },
     { "STOREQ", "", 0, 1 },
     { "LDKQ", "1", 0, 2 },
     { "LDKQ", "2", 0, 3 },
     { "INCL", "1", 0, 2 },
     { "DECL", "1", 0, 2 },
     { "DUP", "N", 0, 1 },
     { "DUP", "N", 1, 1 },
     { "DUP", "N", 2, 1 },
     { "SWAP", "", 0, 1 },
     { "POP", "1", 0, 2 },
     { "PLUS", "", 0, 1 },
     { "MINUS", "", 0, 1 },
     { "TIMES", "", 0, 1 },
     { "UMINUS", "", 0, 1 },
     { "AND", "", 0, 1 },
     { "OR", "", 0, 1 },
     { "NOT", "", 0, 1 },
     { "INC", "", 0, 1 },
     { "DEC", "", 0, 1 },
     { "BITAND", "", 0, 1 },
     { "BITOR", "", 0, 1 },
     { "BITXOR", "", 0, 1 },
     { "BITNOT", "", 0, 1 },
     { "BITSUB", "", 0, 1 },
     { "BIT", "", 0, 1 },
     { "LSL", "", 0, 1 },
     { "LSR", "", 0, 1 },
     { "ASR", "", 0, 1 },
     { "DIV", "", 0, 1 },
     { "MOD", "", 0, 1 },
     { "EQ", "", 0, 1 },
     { "LT", "", 0, 1 },
     { "GT", "", 0, 1 },
     { "LEQ", "", 0, 1 },
     { "GEQ", "", 0, 1 },
     { "NEQ", "", 0, 1 },
     { "JEQ", "S", 0, 2 },
     { "JEQ", "R", 0, 3 },
     { "JLT", "S", 0, 2 },
     { "JLT", "R", 0, 3 },
     { "JGT", "S", 0, 2 },
     { "JGT", "R", 0, 3 },
     { "JLEQ", "S", 0, 2 },
     { "JLEQ", "R", 0, 3 },
     { "JGEQ", "S", 0, 2 },
     { "JGEQ", "R", 0, 3 },
     { "JNEQ", "S", 0, 2 },
     { "JNEQ", "R", 0, 3 },
     { "JLTZ", "S", 0, 2 },
     { "JGTZ", "S", 0, 2 },
     { "JLEQZ", "S", 0, 2 },
     { "JGEQZ", "S", 0, 2 },
     { "JNEQZ", "S", 0, 2 },
     { "JNEQZ", "R", 0, 3 },
     { "JEQZ", "S", 0, 2 },
     { "JEQZ", "R", 0, 3 },
     { "JUMP", "S", 0, 2 },
     { "JUMP", "R", 0, 3 },
     { "QPLUS", "", 0, 1 },
     { "QMINUS", "", 0, 1 },
     { "QTIMES", "", 0, 1 },
     { "QUMINUS", "", 0, 1 },
     { "QDIV", "", 0, 1 },
     { "QMOD", "", 0, 1 },
     { "JCASE", "1", 0, 2 },
     { "JRANGE", "S", 0, 2 },
     { "JRANGE", "R", 0, 3 },
     { "TESTGEQ", "S", 0, 2 },
     { "TESTGEQ", "R", 0, 3 },
     { "FPLUS", "", 0, 1 },
     { "FMINUS", "", 0, 1 },
     { "FTIMES", "", 0, 1 },
     { "FDIV", "", 0, 1 },
     { "FUMINUS", "", 0, 1 },
     { "FCMP", "", 0, 1 },
     { "DPLUS", "", 0, 1 },
     { "DMINUS", "", 0, 1 },
     { "DTIMES", "", 0, 1 },
     { "DDIV", "", 0, 1 },
     { "DUMINUS", "", 0, 1 },
     { "DCMP", "", 0, 1 },
     { "QCMP", "", 0, 1 },
     { "CONVNF", "", 0, 1 },
     { "CONVND", "", 0, 1 },
     { "CONVFD", "", 0, 1 },
     { "CONVDF", "", 0, 1 },
     { "CONVNC", "", 0, 1 },
     { "CONVNS", "", 0, 1 },
     { "CONVNQ", "", 0, 1 },
     { "CONVQN", "", 0, 1 },
     { "CONVQD", "", 0, 1 },
     { "BOUND", "2", 0, 3 },
     { "NCHECK", "2", 0, 3 },
     { "GCHECK", "2", 0, 3 },
     { "ZCHECK", "2", 0, 3 },
     { "FZCHECK", "2", 0, 3 },
     { "DZCHECK", "2", 0, 3 },
     { "QZCHECK", "2", 0, 3 },
     { "ERROR", "12", 0, 4 },
     { "ALIGNC", "", 0, 1 },
     { "ALIGNS", "", 0, 1 },
     { "FIXCOPY", "", 0, 1 },
     { "FLEXCOPY", "", 0, 1 },
     { "TYPETEST", "1", 0, 2 },
     { "LINK", "", 0, 1 },
     { "SAVELINK", "", 0, 1 },
     { "JPROC", "", 0, 1 },
     { "SLIDE", "1", 0, 2 },
     { "SLIDEW", "1", 0, 2 },
     { "SLIDED", "1", 0, 2 },
     { "SLIDEF", "1", 0, 2 },
     { "SLIDEQ", "1", 0, 2 },
     { "RESULTW", "", 0, 1 },
     { "RESULTD", "", 0, 1 },
     { "RESULTF", "", 0, 1 },
     { "RESULTQ", "", 0, 1 },
     { "RETURN", "", 0, 1 },
     { "LNUM", "2", 0, 3 },
     { "BREAK", "2", 0, 3 },
     { "CASEJUMP", "1", 0, 2 },
     { "PACK", "", 0, 1 },
     { "UNPACK", "", 0, 1 },
};
#endif


#define keiko_version  "$Id: keiko.iset 1704 2012-05-02 08:05:11Z mike $"

#define local(n)        ((uchar *) bp + (n))
#define parent(a, t)    indir(bp[SL].x + a, t)
#define indir(p, t)     (* (t *) (p))
#define subs(p, n, t)   ((t *) (p))[n]
#define const(n)        cp[CP_CONST+n]
#define jump(lab)       pc = pc0 + lab


#define dup(n, sp)      sp--; sp[0] = sp[n+1]
#define swap(sp)        sp[-1] = sp[1]; sp[1] = sp[0]; sp[0] = sp[-1]


/* The DIV and MOD instructions must give the correct results, even if 
   C is wrong.  Correct means that b * (a DIV b) + a MOD b = a, and 
   (-a) DIV (-b) = a DIV b, and if b > 0 then 0 <= a MOD b < b. */

static inline divop_decl(int)
static inline divop_decl(longint)


#define jcase(x, n)  if ((unsigned) x < (unsigned) n) { pc0 = pc + 2*x; jump(get2(pc0)); }  else pc += 2*n


static inline int fcmp(double a, double b) {
     /* This doesn't deal well with NaN ... */
     return (a < b ? -1 : a > b ? 1 : 0);
}

static inline int lcmp(longint a, longint b) {
     return (a < b ? -1 : a > b ? 1 : 0);
}


#ifdef i386
#define getdbl get_double
#define putdbl put_double
#define getlong get_long
#define putlong put_long
#else
static inline double getdbl(value *v) {
     dblbuf dd;
     dd.n.lo = v[0].i;
     dd.n.hi = v[1].i;
     return dd.d;
}

static inline void putdbl(value *v, double x) {
     dblbuf dd;
     dd.d = x;
     v[0].i = dd.n.lo;
     v[1].i = dd.n.hi;
}

static inline longint getlong(value *v) {
     dblbuf dd;
     dd.n.lo = v[0].i;
     dd.n.hi = v[1].i;
     return dd.q;
}

static inline void putlong(value *v, longint x) {
     dblbuf dd;
     dd.q = x;
     v[0].i = dd.n.lo;
     v[1].i = dd.n.hi;
}
#endif


#define signext(x)      ((int) (x) << 16 >> 16)


static inline int boundcheck(unsigned i, unsigned n, int line,               
                             value *bp, uchar *pc) {         
     if (i >= n) runtime_error(E_BOUND, line, bp, pc);
     return i;                                               
}

#define checkdef(name, type, arg, test, msg)                             static inline type name(type arg, int line,                         value *bp, uchar *pc) {                     if (test) runtime_error(msg, line, bp, pc);                    return arg;                                                    }

checkdef(nullcheck, uchar *, p, p == NULL, E_NULL)
checkdef(zerocheck, int, n, n == 0, E_DIV)
checkdef(fzerocheck, double, x, x == 0.0, E_FDIV)
checkdef(lzerocheck, longint, n, n == 0, E_DIV)
checkdef(globcheck, value *, p, p != NULL, E_GLOB)

/* TYPETEST n expects two descriptor addresses d1 and d2:
   it test whether the ancestor of d1 at level n is d2. */
static inline int typetest(value *d1, value *d2, int n) {
     return (d1[DESC_DEPTH].i >= n && d1[DESC_ANCES].p[n].p == d2);
}

#define czech(chk, a, n) chk(a, n, bp, pc0)
#define czech2(chk, a, b, n) chk(a, b, n, bp, pc0)
#define error(msg, n) runtime_error(msg, n, bp, pc0);


#ifdef WORDS_BIGENDIAN
#define alignx(a, n)    (a <<= (32-n))
#else
#define alignx(a, n)    a
#endif


#ifdef PROFILE
#define prof_charge(n)  ticks += n
#else
#define prof_charge(n)
#endif


#define fixcopy(a, b, n) prof_charge(n/4); memcpy(a, b, n)


#define flexcopy(d0, size0)                                              { value *d = (value *) d0; int size = size0;                        int sizew = (size+3)/4; prof_charge(sizew);                       sp -= sizew;                                                      if ((uchar *) sp < stack + SLIMIT)                                error(E_STACK, 0);                                           memcpy(sp, d[0].x, size);                                         d[0].x = (uchar *) sp;}


#define frame()                                                          bp = sp;                                                            sp = (value *) ((uchar *) bp - cp[CP_FRAME].i);                     if ((uchar *) sp < stack + SLIMIT) error(E_STACK, 0);               memset(sp, 0, cp[CP_FRAME].i);

#ifdef OBXDEB
#define cond_break()  if (one_shot && *pc != K_LNUM_2 && *pc != K_BREAK_2)  debug_break(cp, bp, pc, "stop")
#else
#define cond_break()
#endif


#define slide(nargs) sp += HEAD + nargs; cond_break();


#define casejump(x, n0)                                  {                                                   int n = n0;                                    pc0 = pc; pc += 4*n;                           while (n > 0) {                                if (x == get2(pc0)) {                     jump(get2(pc0+2));                   break;                               }                                         pc0 += 4; n--;                            }                                              }



/* interp -- main loop of the interpreter */
void interp(value *sp0) {
     register value *cp = sp0[CP].p;
     uchar *pc = cp[CP_CODE].x;
     register uchar *pc0 = NULL;
     register value *sp = sp0;
     register uchar ir = 0;
#ifdef PROFILE
     register counter ticks = 0;
#endif
     register value *bp = NULL;
     value *base = sp0;
#ifdef TRACE
     proc thisproc = NULL;
#endif

#ifdef JTABLE
     /* Save time by using gcc's label array feature */
     static void *jtable[256] = {
          &&lbl_ILLEGAL,
          &&lbl_PUSH_x1,
          &&lbl_PUSH_x1,
          &&lbl_PUSH_x1,
          &&lbl_PUSH_x1,
          &&lbl_PUSH_x1,
          &&lbl_PUSH_x1,
          &&lbl_PUSH_x1,
          &&lbl_PUSH_x1,
          &&lbl_PUSH_1,
          &&lbl_PUSH_2,
          &&lbl_LDKW_1,
          &&lbl_LDKW_2,
          &&lbl_LDKF_1,
          &&lbl_LDKF_2,
          &&lbl_LOCAL_1,
          &&lbl_LOCAL_2,
          &&lbl_INDEXC,
          &&lbl_INDEXS,
          &&lbl_INDEXW,
          &&lbl_INDEXD,
          &&lbl_LOADW,
          &&lbl_LOADS,
          &&lbl_LOADC,
          &&lbl_LOADF,
          &&lbl_STOREW,
          &&lbl_STORES,
          &&lbl_STOREC,
          &&lbl_STOREF,
          &&lbl_LDLW_x1,
          &&lbl_LDLW_x1,
          &&lbl_LDLW_x1,
          &&lbl_LDLW_x1,
          &&lbl_LDLW_x1,
          &&lbl_LDLW_x1,
          &&lbl_LDLW_x2,
          &&lbl_LDLW_x2,
          &&lbl_LDLW_x2,
          &&lbl_LDLW_x2,
          &&lbl_LDLW_x2,
          &&lbl_LDLW_x2,
          &&lbl_LDLW_1,
          &&lbl_LDLW_2,
          &&lbl_LDLS_1,
          &&lbl_LDLS_2,
          &&lbl_LDLC_1,
          &&lbl_LDLC_2,
          &&lbl_LDLF_1,
          &&lbl_LDLF_2,
          &&lbl_STLW_x1,
          &&lbl_STLW_x1,
          &&lbl_STLW_x1,
          &&lbl_STLW_x1,
          &&lbl_STLW_x1,
          &&lbl_STLW_x1,
          &&lbl_STLW_x2,
          &&lbl_STLW_x2,
          &&lbl_STLW_x2,
          &&lbl_STLW_x2,
          &&lbl_STLW_x2,
          &&lbl_STLW_x2,
          &&lbl_STLW_1,
          &&lbl_STLW_2,
          &&lbl_STLS_1,
          &&lbl_STLS_2,
          &&lbl_STLC_1,
          &&lbl_STLC_2,
          &&lbl_STLF_1,
          &&lbl_STLF_2,
          &&lbl_LDGW_K,
          &&lbl_LDGW_L,
          &&lbl_LDGS_K,
          &&lbl_LDGS_L,
          &&lbl_LDGC_K,
          &&lbl_LDGC_L,
          &&lbl_LDGF_K,
          &&lbl_LDGF_L,
          &&lbl_STGW_K,
          &&lbl_STGW_L,
          &&lbl_STGS_K,
          &&lbl_STGS_L,
          &&lbl_STGC_K,
          &&lbl_STGC_L,
          &&lbl_STGF_K,
          &&lbl_STGF_L,
          &&lbl_LDNW_x1,
          &&lbl_LDNW_x1,
          &&lbl_LDNW_x1,
          &&lbl_LDNW_x1,
          &&lbl_LDNW_x1,
          &&lbl_LDNW_x1,
          &&lbl_LDNW_x1,
          &&lbl_LDNW_x1,
          &&lbl_LDNW_x1,
          &&lbl_LDNW_x1,
          &&lbl_LDNW_x1,
          &&lbl_LDNW_x1,
          &&lbl_LDNW_x1,
          &&lbl_LDNW_x1,
          &&lbl_LDNW_x1,
          &&lbl_LDNW_1,
          &&lbl_LDNW_2,
          &&lbl_STNW_x1,
          &&lbl_STNW_x1,
          &&lbl_STNW_x1,
          &&lbl_STNW_x1,
          &&lbl_STNW_x1,
          &&lbl_STNW_x1,
          &&lbl_STNW_x1,
          &&lbl_STNW_x1,
          &&lbl_STNW_x1,
          &&lbl_STNW_x1,
          &&lbl_STNW_1,
          &&lbl_STNW_2,
          &&lbl_LDIW,
          &&lbl_LDIF,
          &&lbl_LDIS,
          &&lbl_LDIC,
          &&lbl_STIW,
          &&lbl_STIF,
          &&lbl_STIS,
          &&lbl_STIC,
          &&lbl_LDEW_1,
          &&lbl_LDEW_2,
          &&lbl_STEW_1,
          &&lbl_STEW_2,
          &&lbl_LOADD,
          &&lbl_STORED,
          &&lbl_LDKD_1,
          &&lbl_LDKD_2,
          &&lbl_LOADQ,
          &&lbl_STOREQ,
          &&lbl_LDKQ_1,
          &&lbl_LDKQ_2,
          &&lbl_INCL_1,
          &&lbl_DECL_1,
          &&lbl_DUP,
          &&lbl_DUP,
          &&lbl_DUP,
          &&lbl_SWAP,
          &&lbl_POP_1,
          &&lbl_PLUS,
          &&lbl_MINUS,
          &&lbl_TIMES,
          &&lbl_UMINUS,
          &&lbl_AND,
          &&lbl_OR,
          &&lbl_NOT,
          &&lbl_INC,
          &&lbl_DEC,
          &&lbl_BITAND,
          &&lbl_BITOR,
          &&lbl_BITXOR,
          &&lbl_BITNOT,
          &&lbl_BITSUB,
          &&lbl_BIT,
          &&lbl_LSL,
          &&lbl_LSR,
          &&lbl_ASR,
          &&lbl_DIV,
          &&lbl_MOD,
          &&lbl_EQ,
          &&lbl_LT,
          &&lbl_GT,
          &&lbl_LEQ,
          &&lbl_GEQ,
          &&lbl_NEQ,
          &&lbl_JEQ_S,
          &&lbl_JEQ_R,
          &&lbl_JLT_S,
          &&lbl_JLT_R,
          &&lbl_JGT_S,
          &&lbl_JGT_R,
          &&lbl_JLEQ_S,
          &&lbl_JLEQ_R,
          &&lbl_JGEQ_S,
          &&lbl_JGEQ_R,
          &&lbl_JNEQ_S,
          &&lbl_JNEQ_R,
          &&lbl_JLTZ_S,
          &&lbl_JGTZ_S,
          &&lbl_JLEQZ_S,
          &&lbl_JGEQZ_S,
          &&lbl_JNEQZ_S,
          &&lbl_JNEQZ_R,
          &&lbl_JEQZ_S,
          &&lbl_JEQZ_R,
          &&lbl_JUMP_S,
          &&lbl_JUMP_R,
          &&lbl_QPLUS,
          &&lbl_QMINUS,
          &&lbl_QTIMES,
          &&lbl_QUMINUS,
          &&lbl_QDIV,
          &&lbl_QMOD,
          &&lbl_JCASE_1,
          &&lbl_JRANGE_S,
          &&lbl_JRANGE_R,
          &&lbl_TESTGEQ_S,
          &&lbl_TESTGEQ_R,
          &&lbl_FPLUS,
          &&lbl_FMINUS,
          &&lbl_FTIMES,
          &&lbl_FDIV,
          &&lbl_FUMINUS,
          &&lbl_FCMP,
          &&lbl_DPLUS,
          &&lbl_DMINUS,
          &&lbl_DTIMES,
          &&lbl_DDIV,
          &&lbl_DUMINUS,
          &&lbl_DCMP,
          &&lbl_QCMP,
          &&lbl_CONVNF,
          &&lbl_CONVND,
          &&lbl_CONVFD,
          &&lbl_CONVDF,
          &&lbl_CONVNC,
          &&lbl_CONVNS,
          &&lbl_CONVNQ,
          &&lbl_CONVQN,
          &&lbl_CONVQD,
          &&lbl_BOUND_2,
          &&lbl_NCHECK_2,
          &&lbl_GCHECK_2,
          &&lbl_ZCHECK_2,
          &&lbl_FZCHECK_2,
          &&lbl_DZCHECK_2,
          &&lbl_QZCHECK_2,
          &&lbl_ERROR_12,
          &&lbl_ALIGNC,
          &&lbl_ALIGNS,
          &&lbl_FIXCOPY,
          &&lbl_FLEXCOPY,
          &&lbl_TYPETEST_1,
          &&lbl_LINK,
          &&lbl_SAVELINK,
          &&lbl_JPROC,
          &&lbl_SLIDE_1,
          &&lbl_SLIDEW_1,
          &&lbl_SLIDED_1,
          &&lbl_SLIDEF_1,
          &&lbl_SLIDEQ_1,
          &&lbl_RESULTW,
          &&lbl_RESULTD,
          &&lbl_RESULTF,
          &&lbl_RESULTQ,
          &&lbl_RETURN,
          &&lbl_LNUM_2,
          &&lbl_BREAK_2,
          &&lbl_CASEJUMP_1,
          &&lbl_PACK,
          &&lbl_UNPACK,
          &&lbl_ILLEGAL,
          &&lbl_ILLEGAL,
          &&lbl_ILLEGAL,
     };
#endif

#ifdef JTABLE
/* Each action ends with an indexed jump to the next */
#define ACTION(op) lbl_ ## op:
#define ALSO(op)
#define DEFAULT
#define NEXT       goto *jtable[ir = *(pc0 = pc)]
#else
/* Actions are just cases in a big switch */
#define ACTION(op) case K_ ## op:
#define ALSO(op)   case K_ ## op:
#define DEFAULT    default:
#define NEXT       break
#endif

     level++;
     do_find_proc;

#ifdef PROFILE
     prof_enter(cp, 0, PROF_CALL);
#endif

     frame();

#ifdef JTABLE
     NEXT;
#else
     while (TRUE) {
#ifdef TRACE
          if (dflag > 1) {
               int i;
               printf("pc=%s+%d(%p) sp=%p bp=%p cp=%p",
                      thisproc->p_name, pc - cp[1].x, pc, sp, bp, cp);
               fflush(stdout);
               for (i = 0; i < 8; i++) printf(" %x", sp[i].i);
               printf("\n");
               printf("%6d: %s\n", pc-imem, fmt_inst(pc));
               fflush(stdout);
          }
#endif

#ifdef PROFILE
          ticks++;
#endif

          switch (ir = *(pc0 = pc)) {
#endif

          ACTION(PUSH_x1)
          ALSO(PUSH_x1+1)
          ALSO(PUSH_x1+2)
          ALSO(PUSH_x1+3)
          ALSO(PUSH_x1+4)
          ALSO(PUSH_x1+5)
          ALSO(PUSH_x1+6)
          ALSO(PUSH_x1+7)
               pc = pc0 + 1;
               sp--; sp[0].i = ir-2;
               NEXT;

          ACTION(PUSH_1)
               pc = pc0 + 2;
               sp--; sp[0].i = get1(pc0+1);
               NEXT;

          ACTION(PUSH_2)
               pc = pc0 + 3;
               sp--; sp[0].i = get2(pc0+1);
               NEXT;

          ACTION(LDKW_1)
               pc = pc0 + 2;
               sp--; sp[0].i = const(get1(pc0+1)).i;
               NEXT;

          ACTION(LDKW_2)
               pc = pc0 + 3;
               sp--; sp[0].i = const(get2(pc0+1)).i;
               NEXT;

          ACTION(LDKF_1)
               pc = pc0 + 2;
               sp--; sp[0].f = const(get1(pc0+1)).f;
               NEXT;

          ACTION(LDKF_2)
               pc = pc0 + 3;
               sp--; sp[0].f = const(get2(pc0+1)).f;
               NEXT;

          ACTION(LOCAL_1)
               pc = pc0 + 2;
               sp--; sp[0].x = local(get1(pc0+1));
               NEXT;

          ACTION(LOCAL_2)
               pc = pc0 + 3;
               sp--; sp[0].x = local(get2(pc0+1));
               NEXT;

          ACTION(INDEXC)
               pc = pc0 + 1;
               sp++; sp[0].x = sp[0].x + sp[-1].i;
               NEXT;

          ACTION(INDEXS)
               pc = pc0 + 1;
               sp++; sp[0].x = sp[0].x + (sp[-1].i<<1);
               NEXT;

          ACTION(INDEXW)
               pc = pc0 + 1;
               sp++; sp[0].x = sp[0].x + (sp[-1].i<<2);
               NEXT;

          ACTION(INDEXD)
               pc = pc0 + 1;
               sp++; sp[0].x = sp[0].x + (sp[-1].i<<3);
               NEXT;

          ACTION(LOADW)
               pc = pc0 + 1;
               sp[0].i = indir(sp[0].x, int);
               NEXT;

          ACTION(LOADS)
               pc = pc0 + 1;
               sp[0].i = indir(sp[0].x, short);
               NEXT;

          ACTION(LOADC)
               pc = pc0 + 1;
               sp[0].i = indir(sp[0].x, uchar);
               NEXT;

          ACTION(LOADF)
               pc = pc0 + 1;
               sp[0].f = indir(sp[0].x, float);
               NEXT;

          ACTION(STOREW)
               pc = pc0 + 1;
               sp += 2; { indir(sp[-2].x, int) = sp[-1].i; }
               NEXT;

          ACTION(STORES)
               pc = pc0 + 1;
               sp += 2; { indir(sp[-2].x, short) = sp[-1].i; }
               NEXT;

          ACTION(STOREC)
               pc = pc0 + 1;
               sp += 2; { indir(sp[-2].x, uchar) = sp[-1].i; }
               NEXT;

          ACTION(STOREF)
               pc = pc0 + 1;
               sp += 2; { indir(sp[-2].x, float) = sp[-1].f; }
               NEXT;

          ACTION(LDLW_x1)
          ALSO(LDLW_x1+1)
          ALSO(LDLW_x1+2)
          ALSO(LDLW_x1+3)
          ALSO(LDLW_x1+4)
          ALSO(LDLW_x1+5)
               pc = pc0 + 1;
               sp--; sp[0].i = indir(local(ir*4-140), int);
               NEXT;

          ACTION(LDLW_x2)
          ALSO(LDLW_x2+1)
          ALSO(LDLW_x2+2)
          ALSO(LDLW_x2+3)
          ALSO(LDLW_x2+4)
          ALSO(LDLW_x2+5)
               pc = pc0 + 1;
               sp--; sp[0].i = indir(local(ir*4-128), int);
               NEXT;

          ACTION(LDLW_1)
               pc = pc0 + 2;
               sp--; sp[0].i = indir(local(get1(pc0+1)), int);
               NEXT;

          ACTION(LDLW_2)
               pc = pc0 + 3;
               sp--; sp[0].i = indir(local(get2(pc0+1)), int);
               NEXT;

          ACTION(LDLS_1)
               pc = pc0 + 2;
               sp--; sp[0].i = indir(local(get1(pc0+1)), short);
               NEXT;

          ACTION(LDLS_2)
               pc = pc0 + 3;
               sp--; sp[0].i = indir(local(get2(pc0+1)), short);
               NEXT;

          ACTION(LDLC_1)
               pc = pc0 + 2;
               sp--; sp[0].i = indir(local(get1(pc0+1)), uchar);
               NEXT;

          ACTION(LDLC_2)
               pc = pc0 + 3;
               sp--; sp[0].i = indir(local(get2(pc0+1)), uchar);
               NEXT;

          ACTION(LDLF_1)
               pc = pc0 + 2;
               sp--; sp[0].f = indir(local(get1(pc0+1)), float);
               NEXT;

          ACTION(LDLF_2)
               pc = pc0 + 3;
               sp--; sp[0].f = indir(local(get2(pc0+1)), float);
               NEXT;

          ACTION(STLW_x1)
          ALSO(STLW_x1+1)
          ALSO(STLW_x1+2)
          ALSO(STLW_x1+3)
          ALSO(STLW_x1+4)
          ALSO(STLW_x1+5)
               pc = pc0 + 1;
               sp += 1; { indir(local(ir*4-220), int) = sp[-1].i; }
               NEXT;

          ACTION(STLW_x2)
          ALSO(STLW_x2+1)
          ALSO(STLW_x2+2)
          ALSO(STLW_x2+3)
          ALSO(STLW_x2+4)
          ALSO(STLW_x2+5)
               pc = pc0 + 1;
               sp += 1; { indir(local(ir*4-208), int) = sp[-1].i; }
               NEXT;

          ACTION(STLW_1)
               pc = pc0 + 2;
               sp += 1; { indir(local(get1(pc0+1)), int) = sp[-1].i; }
               NEXT;

          ACTION(STLW_2)
               pc = pc0 + 3;
               sp += 1; { indir(local(get2(pc0+1)), int) = sp[-1].i; }
               NEXT;

          ACTION(STLS_1)
               pc = pc0 + 2;
               sp += 1; { indir(local(get1(pc0+1)), short) = sp[-1].i; }
               NEXT;

          ACTION(STLS_2)
               pc = pc0 + 3;
               sp += 1; { indir(local(get2(pc0+1)), short) = sp[-1].i; }
               NEXT;

          ACTION(STLC_1)
               pc = pc0 + 2;
               sp += 1; { indir(local(get1(pc0+1)), uchar) = sp[-1].i; }
               NEXT;

          ACTION(STLC_2)
               pc = pc0 + 3;
               sp += 1; { indir(local(get2(pc0+1)), uchar) = sp[-1].i; }
               NEXT;

          ACTION(STLF_1)
               pc = pc0 + 2;
               sp += 1; { indir(local(get1(pc0+1)), float) = sp[-1].f; }
               NEXT;

          ACTION(STLF_2)
               pc = pc0 + 3;
               sp += 1; { indir(local(get2(pc0+1)), float) = sp[-1].f; }
               NEXT;

          ACTION(LDGW_K)
               pc = pc0 + 2;
               sp--; sp[0].i = indir(const(get1(pc0+1)).x, int);
               NEXT;

          ACTION(LDGW_L)
               pc = pc0 + 3;
               sp--; sp[0].i = indir(const(get2(pc0+1)).x, int);
               NEXT;

          ACTION(LDGS_K)
               pc = pc0 + 2;
               sp--; sp[0].i = indir(const(get1(pc0+1)).x, short);
               NEXT;

          ACTION(LDGS_L)
               pc = pc0 + 3;
               sp--; sp[0].i = indir(const(get2(pc0+1)).x, short);
               NEXT;

          ACTION(LDGC_K)
               pc = pc0 + 2;
               sp--; sp[0].i = indir(const(get1(pc0+1)).x, uchar);
               NEXT;

          ACTION(LDGC_L)
               pc = pc0 + 3;
               sp--; sp[0].i = indir(const(get2(pc0+1)).x, uchar);
               NEXT;

          ACTION(LDGF_K)
               pc = pc0 + 2;
               sp--; sp[0].f = indir(const(get1(pc0+1)).x, float);
               NEXT;

          ACTION(LDGF_L)
               pc = pc0 + 3;
               sp--; sp[0].f = indir(const(get2(pc0+1)).x, float);
               NEXT;

          ACTION(STGW_K)
               pc = pc0 + 2;
               sp += 1; { indir(const(get1(pc0+1)).x, int) = sp[-1].i; }
               NEXT;

          ACTION(STGW_L)
               pc = pc0 + 3;
               sp += 1; { indir(const(get2(pc0+1)).x, int) = sp[-1].i; }
               NEXT;

          ACTION(STGS_K)
               pc = pc0 + 2;
               sp += 1; { indir(const(get1(pc0+1)).x, short) = sp[-1].i; }
               NEXT;

          ACTION(STGS_L)
               pc = pc0 + 3;
               sp += 1; { indir(const(get2(pc0+1)).x, short) = sp[-1].i; }
               NEXT;

          ACTION(STGC_K)
               pc = pc0 + 2;
               sp += 1; { indir(const(get1(pc0+1)).x, uchar) = sp[-1].i; }
               NEXT;

          ACTION(STGC_L)
               pc = pc0 + 3;
               sp += 1; { indir(const(get2(pc0+1)).x, uchar) = sp[-1].i; }
               NEXT;

          ACTION(STGF_K)
               pc = pc0 + 2;
               sp += 1; { indir(const(get1(pc0+1)).x, float) = sp[-1].f; }
               NEXT;

          ACTION(STGF_L)
               pc = pc0 + 3;
               sp += 1; { indir(const(get2(pc0+1)).x, float) = sp[-1].f; }
               NEXT;

          ACTION(LDNW_x1)
          ALSO(LDNW_x1+1)
          ALSO(LDNW_x1+2)
          ALSO(LDNW_x1+3)
          ALSO(LDNW_x1+4)
          ALSO(LDNW_x1+5)
          ALSO(LDNW_x1+6)
          ALSO(LDNW_x1+7)
          ALSO(LDNW_x1+8)
          ALSO(LDNW_x1+9)
          ALSO(LDNW_x1+10)
          ALSO(LDNW_x1+11)
          ALSO(LDNW_x1+12)
          ALSO(LDNW_x1+13)
          ALSO(LDNW_x1+14)
               pc = pc0 + 1;
               sp[0].i = indir(sp[0].x + ir*4-356, int);
               NEXT;

          ACTION(LDNW_1)
               pc = pc0 + 2;
               sp[0].i = indir(sp[0].x + get1(pc0+1), int);
               NEXT;

          ACTION(LDNW_2)
               pc = pc0 + 3;
               sp[0].i = indir(sp[0].x + get2(pc0+1), int);
               NEXT;

          ACTION(STNW_x1)
          ALSO(STNW_x1+1)
          ALSO(STNW_x1+2)
          ALSO(STNW_x1+3)
          ALSO(STNW_x1+4)
          ALSO(STNW_x1+5)
          ALSO(STNW_x1+6)
          ALSO(STNW_x1+7)
          ALSO(STNW_x1+8)
          ALSO(STNW_x1+9)
               pc = pc0 + 1;
               sp += 2; { indir(sp[-2].x + ir*4-424, int) = sp[-1].i; }
               NEXT;

          ACTION(STNW_1)
               pc = pc0 + 2;
               sp += 2; { indir(sp[-2].x + get1(pc0+1), int) = sp[-1].i; }
               NEXT;

          ACTION(STNW_2)
               pc = pc0 + 3;
               sp += 2; { indir(sp[-2].x + get2(pc0+1), int) = sp[-1].i; }
               NEXT;

          ACTION(LDIW)
               pc = pc0 + 1;
               sp++; sp[0].i = subs(sp[0].x, sp[-1].i, int);
               NEXT;

          ACTION(LDIF)
               pc = pc0 + 1;
               sp++; sp[0].f = subs(sp[0].x, sp[-1].i, float);
               NEXT;

          ACTION(LDIS)
               pc = pc0 + 1;
               sp++; sp[0].i = subs(sp[0].x, sp[-1].i, short);
               NEXT;

          ACTION(LDIC)
               pc = pc0 + 1;
               sp++; sp[0].i = subs(sp[0].x, sp[-1].i, uchar);
               NEXT;

          ACTION(STIW)
               pc = pc0 + 1;
               sp += 3; { subs(sp[-2].x, sp[-3].i, int) = sp[-1].i; }
               NEXT;

          ACTION(STIF)
               pc = pc0 + 1;
               sp += 3; { subs(sp[-2].x, sp[-3].i, float) = sp[-1].f; }
               NEXT;

          ACTION(STIS)
               pc = pc0 + 1;
               sp += 3; { subs(sp[-2].x, sp[-3].i, short) = sp[-1].i; }
               NEXT;

          ACTION(STIC)
               pc = pc0 + 1;
               sp += 3; { subs(sp[-2].x, sp[-3].i, uchar) = sp[-1].i; }
               NEXT;

          ACTION(LDEW_1)
               pc = pc0 + 2;
               sp--; sp[0].i = parent(get1(pc0+1), int);
               NEXT;

          ACTION(LDEW_2)
               pc = pc0 + 3;
               sp--; sp[0].i = parent(get2(pc0+1), int);
               NEXT;

          ACTION(STEW_1)
               pc = pc0 + 2;
               sp += 1; { parent(get1(pc0+1), int) = sp[-1].i; }
               NEXT;

          ACTION(STEW_2)
               pc = pc0 + 3;
               sp += 1; { parent(get2(pc0+1), int) = sp[-1].i; }
               NEXT;

          ACTION(LOADD)
               pc = pc0 + 1;
               sp--; putdbl(&sp[0], getdbl(sp[1].p));
               NEXT;

          ACTION(STORED)
               pc = pc0 + 1;
               sp += 3; { putdbl(sp[-3].p, getdbl(&sp[-2])); }
               NEXT;

          ACTION(LDKD_1)
               pc = pc0 + 2;
               sp -= 2; putdbl(&sp[0], getdbl(&const(get1(pc0+1))));
               NEXT;

          ACTION(LDKD_2)
               pc = pc0 + 3;
               sp -= 2; putdbl(&sp[0], getdbl(&const(get2(pc0+1))));
               NEXT;

          ACTION(LOADQ)
               pc = pc0 + 1;
               sp--; putlong(&sp[0], getlong(sp[1].p));
               NEXT;

          ACTION(STOREQ)
               pc = pc0 + 1;
               sp += 3; { putlong(sp[-3].p, getlong(&sp[-2])); }
               NEXT;

          ACTION(LDKQ_1)
               pc = pc0 + 2;
               sp -= 2; putlong(&sp[0], getlong(&const(get1(pc0+1))));
               NEXT;

          ACTION(LDKQ_2)
               pc = pc0 + 3;
               sp -= 2; putlong(&sp[0], getlong(&const(get2(pc0+1))));
               NEXT;

          ACTION(INCL_1)
               pc = pc0 + 2;
               { indir(local(get1(pc0+1)), int)++; }
               NEXT;

          ACTION(DECL_1)
               pc = pc0 + 2;
               { indir(local(get1(pc0+1)), int)--; }
               NEXT;

          ACTION(DUP)
          ALSO(DUP+1)
          ALSO(DUP+2)
               pc = pc0 + 1;
               { dup(ir-136, sp); }
               NEXT;

          ACTION(SWAP)
               pc = pc0 + 1;
               { swap(sp); }
               NEXT;

          ACTION(POP_1)
               pc = pc0 + 2;
               { sp += get1(pc0+1); }
               NEXT;

          ACTION(PLUS)
               pc = pc0 + 1;
               sp++; sp[0].i = sp[0].i + sp[-1].i;
               NEXT;

          ACTION(MINUS)
               pc = pc0 + 1;
               sp++; sp[0].i = sp[0].i - sp[-1].i;
               NEXT;

          ACTION(TIMES)
               pc = pc0 + 1;
               sp++; sp[0].i = sp[0].i * sp[-1].i;
               NEXT;

          ACTION(UMINUS)
               pc = pc0 + 1;
               sp[0].i = - sp[0].i;
               NEXT;

          ACTION(AND)
               pc = pc0 + 1;
               sp++; sp[0].i = sp[0].i && sp[-1].i;
               NEXT;

          ACTION(OR)
               pc = pc0 + 1;
               sp++; sp[0].i = sp[0].i || sp[-1].i;
               NEXT;

          ACTION(NOT)
               pc = pc0 + 1;
               sp[0].i = ! sp[0].i;
               NEXT;

          ACTION(INC)
               pc = pc0 + 1;
               sp[0].i = sp[0].i + 1;
               NEXT;

          ACTION(DEC)
               pc = pc0 + 1;
               sp[0].i = sp[0].i - 1;
               NEXT;

          ACTION(BITAND)
               pc = pc0 + 1;
               sp++; sp[0].i = sp[0].i & sp[-1].i;
               NEXT;

          ACTION(BITOR)
               pc = pc0 + 1;
               sp++; sp[0].i = sp[0].i | sp[-1].i;
               NEXT;

          ACTION(BITXOR)
               pc = pc0 + 1;
               sp++; sp[0].i = sp[0].i ^ sp[-1].i;
               NEXT;

          ACTION(BITNOT)
               pc = pc0 + 1;
               sp[0].i = ~ sp[0].i;
               NEXT;

          ACTION(BITSUB)
               pc = pc0 + 1;
               sp++; sp[0].i = sp[0].i & ~sp[-1].i;
               NEXT;

          ACTION(BIT)
               pc = pc0 + 1;
               sp[0].i = bit[sp[0].i];
               NEXT;

          ACTION(LSL)
               pc = pc0 + 1;
               sp++; sp[0].i = sp[0].i << sp[-1].i;
               NEXT;

          ACTION(LSR)
               pc = pc0 + 1;
               sp++; sp[0].i = ((unsigned) sp[0].i) >> sp[-1].i;
               NEXT;

          ACTION(ASR)
               pc = pc0 + 1;
               sp++; sp[0].i = sp[0].i >> sp[-1].i;
               NEXT;

          ACTION(DIV)
               pc = pc0 + 1;
               sp++; sp[0].i = int_divop(sp[0].i, sp[-1].i, 1);
               NEXT;

          ACTION(MOD)
               pc = pc0 + 1;
               sp++; sp[0].i = int_divop(sp[0].i, sp[-1].i, 0);
               NEXT;

          ACTION(EQ)
               pc = pc0 + 1;
               sp++; sp[0].i = sp[0].i == sp[-1].i;
               NEXT;

          ACTION(LT)
               pc = pc0 + 1;
               sp++; sp[0].i = sp[0].i < sp[-1].i;
               NEXT;

          ACTION(GT)
               pc = pc0 + 1;
               sp++; sp[0].i = sp[0].i > sp[-1].i;
               NEXT;

          ACTION(LEQ)
               pc = pc0 + 1;
               sp++; sp[0].i = sp[0].i <= sp[-1].i;
               NEXT;

          ACTION(GEQ)
               pc = pc0 + 1;
               sp++; sp[0].i = sp[0].i >= sp[-1].i;
               NEXT;

          ACTION(NEQ)
               pc = pc0 + 1;
               sp++; sp[0].i = sp[0].i != sp[-1].i;
               NEXT;

          ACTION(JEQ_S)
               pc = pc0 + 2;
               sp += 2; { if (sp[-1].i == sp[-2].i) jump(get1(pc0+1)); }
               NEXT;

          ACTION(JEQ_R)
               pc = pc0 + 3;
               sp += 2; { if (sp[-1].i == sp[-2].i) jump(get2(pc0+1)); }
               NEXT;

          ACTION(JLT_S)
               pc = pc0 + 2;
               sp += 2; { if (sp[-1].i < sp[-2].i) jump(get1(pc0+1)); }
               NEXT;

          ACTION(JLT_R)
               pc = pc0 + 3;
               sp += 2; { if (sp[-1].i < sp[-2].i) jump(get2(pc0+1)); }
               NEXT;

          ACTION(JGT_S)
               pc = pc0 + 2;
               sp += 2; { if (sp[-1].i > sp[-2].i) jump(get1(pc0+1)); }
               NEXT;

          ACTION(JGT_R)
               pc = pc0 + 3;
               sp += 2; { if (sp[-1].i > sp[-2].i) jump(get2(pc0+1)); }
               NEXT;

          ACTION(JLEQ_S)
               pc = pc0 + 2;
               sp += 2; { if (sp[-1].i <= sp[-2].i) jump(get1(pc0+1)); }
               NEXT;

          ACTION(JLEQ_R)
               pc = pc0 + 3;
               sp += 2; { if (sp[-1].i <= sp[-2].i) jump(get2(pc0+1)); }
               NEXT;

          ACTION(JGEQ_S)
               pc = pc0 + 2;
               sp += 2; { if (sp[-1].i >= sp[-2].i) jump(get1(pc0+1)); }
               NEXT;

          ACTION(JGEQ_R)
               pc = pc0 + 3;
               sp += 2; { if (sp[-1].i >= sp[-2].i) jump(get2(pc0+1)); }
               NEXT;

          ACTION(JNEQ_S)
               pc = pc0 + 2;
               sp += 2; { if (sp[-1].i != sp[-2].i) jump(get1(pc0+1)); }
               NEXT;

          ACTION(JNEQ_R)
               pc = pc0 + 3;
               sp += 2; { if (sp[-1].i != sp[-2].i) jump(get2(pc0+1)); }
               NEXT;

          ACTION(JLTZ_S)
               pc = pc0 + 2;
               sp += 1; { if (sp[-1].i < 0) jump(get1(pc0+1)); }
               NEXT;

          ACTION(JGTZ_S)
               pc = pc0 + 2;
               sp += 1; { if (sp[-1].i > 0) jump(get1(pc0+1)); }
               NEXT;

          ACTION(JLEQZ_S)
               pc = pc0 + 2;
               sp += 1; { if (sp[-1].i <= 0) jump(get1(pc0+1)); }
               NEXT;

          ACTION(JGEQZ_S)
               pc = pc0 + 2;
               sp += 1; { if (sp[-1].i >= 0) jump(get1(pc0+1)); }
               NEXT;

          ACTION(JNEQZ_S)
               pc = pc0 + 2;
               sp += 1; { if (sp[-1].i != 0) jump(get1(pc0+1)); }
               NEXT;

          ACTION(JNEQZ_R)
               pc = pc0 + 3;
               sp += 1; { if (sp[-1].i != 0) jump(get2(pc0+1)); }
               NEXT;

          ACTION(JEQZ_S)
               pc = pc0 + 2;
               sp += 1; { if (sp[-1].i == 0) jump(get1(pc0+1)); }
               NEXT;

          ACTION(JEQZ_R)
               pc = pc0 + 3;
               sp += 1; { if (sp[-1].i == 0) jump(get2(pc0+1)); }
               NEXT;

          ACTION(JUMP_S)
               pc = pc0 + 2;
               { jump(get1(pc0+1)); }
               NEXT;

          ACTION(JUMP_R)
               pc = pc0 + 3;
               { jump(get2(pc0+1)); }
               NEXT;

          ACTION(QPLUS)
               pc = pc0 + 1;
               sp += 2; putlong(&sp[0], getlong(&sp[0]) + getlong(&sp[-2]));
               NEXT;

          ACTION(QMINUS)
               pc = pc0 + 1;
               sp += 2; putlong(&sp[0], getlong(&sp[0]) - getlong(&sp[-2]));
               NEXT;

          ACTION(QTIMES)
               pc = pc0 + 1;
               sp += 2; putlong(&sp[0], getlong(&sp[0]) * getlong(&sp[-2]));
               NEXT;

          ACTION(QUMINUS)
               pc = pc0 + 1;
               putlong(&sp[0], - getlong(&sp[0]));
               NEXT;

          ACTION(QDIV)
               pc = pc0 + 1;
               sp += 2; putlong(&sp[0], longint_divop(getlong(&sp[0]), getlong(&sp[-2]), 1));
               NEXT;

          ACTION(QMOD)
               pc = pc0 + 1;
               sp += 2; putlong(&sp[0], longint_divop(getlong(&sp[0]), getlong(&sp[-2]), 0));
               NEXT;

          ACTION(JCASE_1)
               pc = pc0 + 2;
               sp += 1; { jcase(sp[-1].i, get1(pc0+1)); }
               NEXT;

          ACTION(JRANGE_S)
               pc = pc0 + 2;
               sp += 3; { if (sp[-1].i >= sp[-2].i && sp[-1].i <= sp[-3].i) jump(get1(pc0+1)); }
               NEXT;

          ACTION(JRANGE_R)
               pc = pc0 + 3;
               sp += 3; { if (sp[-1].i >= sp[-2].i && sp[-1].i <= sp[-3].i) jump(get2(pc0+1)); }
               NEXT;

          ACTION(TESTGEQ_S)
               pc = pc0 + 2;
               sp++; { if (sp[0].i >= sp[-1].i) jump(get1(pc0+1)); }
               NEXT;

          ACTION(TESTGEQ_R)
               pc = pc0 + 3;
               sp++; { if (sp[0].i >= sp[-1].i) jump(get2(pc0+1)); }
               NEXT;

          ACTION(FPLUS)
               pc = pc0 + 1;
               sp++; sp[0].f = sp[0].f + sp[-1].f;
               NEXT;

          ACTION(FMINUS)
               pc = pc0 + 1;
               sp++; sp[0].f = sp[0].f - sp[-1].f;
               NEXT;

          ACTION(FTIMES)
               pc = pc0 + 1;
               sp++; sp[0].f = sp[0].f * sp[-1].f;
               NEXT;

          ACTION(FDIV)
               pc = pc0 + 1;
               sp++; sp[0].f = sp[0].f / sp[-1].f;
               NEXT;

          ACTION(FUMINUS)
               pc = pc0 + 1;
               sp[0].f = - sp[0].f;
               NEXT;

          ACTION(FCMP)
               pc = pc0 + 1;
               sp++; sp[0].i = fcmp(sp[0].f, sp[-1].f);
               NEXT;

          ACTION(DPLUS)
               pc = pc0 + 1;
               sp += 2; putdbl(&sp[0], getdbl(&sp[0]) + getdbl(&sp[-2]));
               NEXT;

          ACTION(DMINUS)
               pc = pc0 + 1;
               sp += 2; putdbl(&sp[0], getdbl(&sp[0]) - getdbl(&sp[-2]));
               NEXT;

          ACTION(DTIMES)
               pc = pc0 + 1;
               sp += 2; putdbl(&sp[0], getdbl(&sp[0]) * getdbl(&sp[-2]));
               NEXT;

          ACTION(DDIV)
               pc = pc0 + 1;
               sp += 2; putdbl(&sp[0], getdbl(&sp[0]) / getdbl(&sp[-2]));
               NEXT;

          ACTION(DUMINUS)
               pc = pc0 + 1;
               putdbl(&sp[0], - getdbl(&sp[0]));
               NEXT;

          ACTION(DCMP)
               pc = pc0 + 1;
               sp += 3; sp[0].i = fcmp(getdbl(&sp[-1]), getdbl(&sp[-3]));
               NEXT;

          ACTION(QCMP)
               pc = pc0 + 1;
               sp += 3; sp[0].i = lcmp(getlong(&sp[-1]), getlong(&sp[-3]));
               NEXT;

          ACTION(CONVNF)
               pc = pc0 + 1;
               sp[0].f = flo_conv(sp[0].i);
               NEXT;

          ACTION(CONVND)
               pc = pc0 + 1;
               sp--; putdbl(&sp[0], flo_conv(sp[1].i));
               NEXT;

          ACTION(CONVFD)
               pc = pc0 + 1;
               sp--; putdbl(&sp[0], sp[1].f);
               NEXT;

          ACTION(CONVDF)
               pc = pc0 + 1;
               sp++; sp[0].f = (float) getdbl(&sp[-1]);
               NEXT;

          ACTION(CONVNC)
               pc = pc0 + 1;
               sp[0].i = sp[0].i & 0xff;
               NEXT;

          ACTION(CONVNS)
               pc = pc0 + 1;
               sp[0].i = signext(sp[0].i);
               NEXT;

          ACTION(CONVNQ)
               pc = pc0 + 1;
               sp--; putlong(&sp[0], sp[1].i);
               NEXT;

          ACTION(CONVQN)
               pc = pc0 + 1;
               sp++; sp[0].i = (int) getlong(&sp[-1]);
               NEXT;

          ACTION(CONVQD)
               pc = pc0 + 1;
               putdbl(&sp[0], flo_convq(getlong(&sp[0])));
               NEXT;

          ACTION(BOUND_2)
               pc = pc0 + 3;
               sp++; sp[0].i = czech2(boundcheck, sp[0].i, sp[-1].i, get2(pc0+1));
               NEXT;

          ACTION(NCHECK_2)
               pc = pc0 + 3;
               sp[0].x = czech(nullcheck, sp[0].x, get2(pc0+1));
               NEXT;

          ACTION(GCHECK_2)
               pc = pc0 + 3;
               sp += 1; { czech(globcheck, sp[-1].p, get2(pc0+1)); }
               NEXT;

          ACTION(ZCHECK_2)
               pc = pc0 + 3;
               sp[0].i = czech(zerocheck, sp[0].i, get2(pc0+1));
               NEXT;

          ACTION(FZCHECK_2)
               pc = pc0 + 3;
               sp[0].f = czech(fzerocheck, sp[0].f, get2(pc0+1));
               NEXT;

          ACTION(DZCHECK_2)
               pc = pc0 + 3;
               putdbl(&sp[0], czech(fzerocheck, getdbl(&sp[0]), get2(pc0+1)));
               NEXT;

          ACTION(QZCHECK_2)
               pc = pc0 + 3;
               putlong(&sp[0], czech(lzerocheck, getlong(&sp[0]), get2(pc0+1)));
               NEXT;

          ACTION(ERROR_12)
               pc = pc0 + 4;
               { error(get1(pc0+1), get2(pc0+2)); }
               NEXT;

          ACTION(ALIGNC)
               pc = pc0 + 1;
               sp[0].i = alignx(sp[0].i, 8);
               NEXT;

          ACTION(ALIGNS)
               pc = pc0 + 1;
               sp[0].i = alignx(sp[0].i, 16);
               NEXT;

          ACTION(FIXCOPY)
               pc = pc0 + 1;
               sp += 3; { fixcopy(sp[-1].x, sp[-2].x, sp[-3].i); }
               NEXT;

          ACTION(FLEXCOPY)
               pc = pc0 + 1;
               sp += 2; { flexcopy(sp[-1].x, sp[-2].i); }
               NEXT;

          ACTION(TYPETEST_1)
               pc = pc0 + 2;
               sp++; sp[0].i = typetest(sp[0].p, sp[-1].p, get1(pc0+1));
               NEXT;

          ACTION(LINK)
               pc = pc0 + 1;
               sp += 1; { statlink = sp[-1].p; }
               NEXT;

          ACTION(SAVELINK)
               pc = pc0 + 1;
               { bp[SL].p = statlink; }
               NEXT;

          ACTION(JPROC)
               pc = pc0 + 1;
               { 
     value *p = sp[0].p;
     sp -= HEAD-1; sp[BP].p = bp; sp[PC].x = pc; sp[CP].p = p;
     if (p[CP_PRIM].z != interp) {
#ifdef PROFILE
          /* Calling a native-code routine */
          prof_enter(p, ticks, PROF_PRIM);
          ticks = 0;
#endif
#ifdef OBXDEB
          prim_bp = sp;
#endif
          (*(p[CP_PRIM].z))(sp);
#ifdef OBXDEB
          prim_bp = NULL;
#endif
     }
     else {
#ifdef PROFILE
          prof_enter(p, ticks, PROF_CALL);
#endif
          cp = p; pc = cp[CP_CODE].x;
          do_find_proc;
          frame();
     }
 }
               NEXT;

          ACTION(SLIDE_1)
               pc = pc0 + 2;
               { slide(get1(pc0+1)); }
               NEXT;

          ACTION(SLIDEW_1)
               pc = pc0 + 2;
               { slide(get1(pc0+1)); sp--; sp[0].i = ob_res.i; }
               NEXT;

          ACTION(SLIDED_1)
               pc = pc0 + 2;
               { slide(get1(pc0+1)); sp -= 2; 
                                putdbl(&sp[0], getdbl(&ob_dres)); }
               NEXT;

          ACTION(SLIDEF_1)
               pc = pc0 + 2;
               { slide(get1(pc0+1)); sp--; sp[0].f = ob_res.f; }
               NEXT;

          ACTION(SLIDEQ_1)
               pc = pc0 + 2;
               { slide(get1(pc0+1)); sp -= 2;
                                putlong(&sp[0], getlong(&ob_dres)); }
               NEXT;

          ACTION(RESULTW)
               pc = pc0 + 1;
               sp += 1; { ob_res = sp[-1]; }
               NEXT;

          ACTION(RESULTD)
               pc = pc0 + 1;
               sp += 2; { putdbl(&ob_dres, getdbl(&sp[-2])); }
               NEXT;

          ACTION(RESULTF)
               pc = pc0 + 1;
               sp += 1; { ob_res.f = sp[-1].f; }
               NEXT;

          ACTION(RESULTQ)
               pc = pc0 + 1;
               sp += 2; { putlong(&ob_dres, getlong(&sp[-2])); }
               NEXT;

          ACTION(RETURN)
               pc = pc0 + 1;
               { 
     if (bp == base) {
          level--;
#ifdef PROFILE
          prof_exit(NULL, ticks);
#endif
          return;
     }

     sp = bp; pc = sp[PC].x; bp = sp[BP].p; cp = bp[CP].p;
     do_find_proc;
#ifdef PROFILE
     prof_exit(cp, ticks);
     ticks = 0;
#endif
     cond_break();
 }
               NEXT;

          ACTION(LNUM_2)
               pc = pc0 + 3;
               { 
#ifdef PROFILE
     if (lflag) { 
          static module m = NULL; /* Cache most recent module */
          ticks--;
          if (m == NULL || cp < (value *) m->m_addr 
                || cp >= (value *) (m->m_addr + m->m_length)) {
               m = find_module(cp);
          }
          m->m_lcount[get2(pc0+1)-1]++; 
     }
#endif
#ifdef OBXDEB
     if (intflag)
          debug_break(cp, bp, pc0, "interrupt");
     else if (one_shot) 
          debug_break(cp, bp, pc0, "stop");
#endif
 }
               NEXT;

          ACTION(BREAK_2)
               pc = pc0 + 3;
               { 
#ifdef OBXDEB
     debug_break(cp, bp, pc0, "break");
#endif
 }
               NEXT;

          ACTION(CASEJUMP_1)
               pc = pc0 + 2;
               sp += 1; { casejump(sp[-1].i, get1(pc0+1)); }
               NEXT;

          ACTION(PACK)
               pc = pc0 + 1;
               sp++; sp[0].i = pack(sp[-1].p, sp[0].x);
               NEXT;

          ACTION(UNPACK)
               pc = pc0 + 1;
               { sp--; sp[0].p = getcode(sp[1].i); 
                                   sp[1].x = getenvt(sp[1].i); }
               NEXT;


          ACTION(ILLEGAL)
          DEFAULT
               panic("*illegal instruction %d", ir);
#ifndef JTABLE
          }
     }
#endif
}

const char *keiko_rcsid = keiko_version;
